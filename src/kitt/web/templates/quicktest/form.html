{% extends "base.html" %}
{% block title %}KITT - New Quick Test{% endblock %}

{% block content %}
<div x-data="quickTest()" class="space-y-6 max-w-3xl" x-init="loadData()">
    <div class="flex items-center justify-between">
        <div>
            <h1 class="text-2xl font-bold">New Quick Test</h1>
            <p class="text-kitt-dim text-sm mt-1">Run a single benchmark quickly on an agent</p>
        </div>
        <a href="/quicktest" class="text-kitt-dim hover:text-white text-sm transition-colors">&larr; Back to history</a>
    </div>

    <div class="bg-kitt-surface rounded-lg p-6 space-y-4">
        <!-- Agent -->
        <div>
            <label class="block text-sm text-kitt-dim mb-1">Agent</label>
            <select x-model="form.agent_id" @change="onAgentChange()"
                    class="w-full bg-kitt-bg border border-kitt-primary/50 rounded-md px-4 py-2 text-sm focus:outline-none focus:border-kitt-accent">
                <option value="">Select an agent...</option>
                {% for agent in agents %}
                <option value="{{ agent.id }}"
                        data-arch="{{ agent.cpu_arch or '' }}">{{ agent.name }} ({{ agent.gpu_info or 'no GPU info' }})</option>
                {% endfor %}
            </select>
        </div>

        <!-- Engine -->
        <div>
            <label class="block text-sm text-kitt-dim mb-1">Engine</label>
            <select x-model="form.engine_name"
                    class="w-full bg-kitt-bg border border-kitt-primary/50 rounded-md px-4 py-2 text-sm focus:outline-none focus:border-kitt-accent">
                <option value="">Select an engine...</option>
                <template x-for="eng in availableEngines" :key="eng.name">
                    <option :value="eng.name"
                            :disabled="!eng.compatible && !overrideCompat"
                            :class="{ 'text-red-400': !eng.compatible }"
                            x-text="eng.label + (eng.compatible ? '' : ' (' + eng.reason + ')')">
                    </option>
                </template>
            </select>
            <template x-if="!selectedEngineCompatible && form.engine_name">
                <p class="text-xs text-yellow-400 mt-1">
                    This engine may not work on the selected agent's platform.
                </p>
            </template>
        </div>

        <!-- Model (searchable combobox) -->
        <div x-data="modelCombobox()" class="relative">
            <label class="block text-sm text-kitt-dim mb-1">Model</label>
            <input type="text"
                   x-model="search"
                   @input="open = true"
                   @focus="open = true"
                   @click="open = true"
                   @keydown.escape="open = false"
                   @keydown.arrow-down.prevent="highlightNext()"
                   @keydown.arrow-up.prevent="highlightPrev()"
                   @keydown.enter.prevent="selectHighlighted()"
                   placeholder="Search models or enter a custom path..."
                   class="w-full bg-kitt-bg border border-kitt-primary/50 rounded-md px-4 py-2 text-sm focus:outline-none focus:border-kitt-accent">

            <!-- Dropdown -->
            <div x-show="open && filtered.length > 0"
                 x-cloak
                 @click.outside="open = false"
                 class="absolute z-10 mt-1 w-full bg-kitt-bg border border-kitt-primary/50 rounded-md shadow-lg max-h-60 overflow-y-auto">
                <template x-for="(model, idx) in filtered" :key="model.model_id">
                    <div @click="selectModel(model)"
                         @mouseenter="highlighted = idx"
                         :class="{ 'bg-kitt-accent/20': highlighted === idx }"
                         class="px-4 py-2 cursor-pointer hover:bg-kitt-accent/10 text-sm">
                        <div class="flex items-center gap-2">
                            <span x-text="model.model_id" class="font-medium"></span>
                            <template x-for="fmt in (model.formats || [])" :key="fmt">
                                <span x-text="fmt" class="text-[10px] px-1.5 py-0.5 rounded bg-kitt-accent/20 text-kitt-accent"></span>
                            </template>
                        </div>
                        <div class="text-xs text-kitt-dim flex gap-3">
                            <span x-text="model.source"></span>
                            <span x-text="formatSize(model.size_bytes)"></span>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Benchmark -->
        <div>
            <label class="block text-sm text-kitt-dim mb-1">Benchmark</label>
            <select x-model="form.benchmark_name"
                    class="w-full bg-kitt-bg border border-kitt-primary/50 rounded-md px-4 py-2 text-sm focus:outline-none focus:border-kitt-accent">
                <option value="throughput">Throughput</option>
                <option value="latency">Latency</option>
                <option value="memory_usage">Memory Usage</option>
                <option value="mmlu">MMLU</option>
                <option value="gsm8k">GSM8K</option>
            </select>
        </div>

        <!-- Override toggle -->
        <div class="flex items-center gap-2">
            <input type="checkbox" id="override-compat" x-model="overrideCompat"
                   class="rounded border-kitt-primary/50 bg-kitt-bg text-kitt-accent focus:ring-kitt-accent">
            <label for="override-compat" class="text-xs text-kitt-dim">
                Show all engines (override compatibility filtering)
            </label>
        </div>

        <button @click="launch()" :disabled="launching || !form.agent_id || !form.engine_name"
                class="w-full bg-kitt-accent hover:bg-kitt-accent/80 disabled:opacity-50 text-white px-6 py-2.5 rounded-md text-sm font-medium transition-colors">
            <span x-show="!launching">Run Test</span>
            <span x-show="launching">Launching...</span>
        </button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Human-readable engine display names
const ENGINE_LABELS = {
    vllm: 'vLLM',
    tgi: 'TGI',
    llama_cpp: 'llama.cpp',
    ollama: 'Ollama',
    exllamav2: 'ExLlamaV2',
    mlx: 'MLX',
};

function quickTest() {
    return {
        form: {
            agent_id: '',
            model_path: '',
            engine_name: '',
            benchmark_name: 'throughput',
        },
        allModels: [],
        engineFormats: {},
        agentCapabilities: {},
        overrideCompat: false,
        launching: false,

        async loadData() {
            try {
                const [modelsResp, formatsResp, capsResp] = await Promise.all([
                    fetch('/api/v1/quicktest/models'),
                    fetch('/api/v1/quicktest/engine-formats'),
                    fetch('/api/v1/quicktest/agent-capabilities'),
                ]);
                this.allModels = await modelsResp.json();
                this.engineFormats = await formatsResp.json();
                this.agentCapabilities = await capsResp.json();
            } catch (e) {
                console.warn('Failed to load data:', e);
            }
        },

        onAgentChange() {
            // Reset engine selection when agent changes — the available
            // engines may differ for the new agent's platform.
            const prev = this.form.engine_name;
            const engines = this.availableEngines;
            const stillAvailable = engines.some(e => e.name === prev && e.compatible);
            if (!stillAvailable) {
                // Pick first compatible engine, or clear
                const first = engines.find(e => e.compatible);
                this.form.engine_name = first ? first.name : '';
            }
        },

        get availableEngines() {
            const caps = this.agentCapabilities[this.form.agent_id];
            const engineEntries = caps ? caps.engines : {};

            // Build list from engine-formats (all known engines)
            const engines = [];
            for (const [name, formats] of Object.entries(this.engineFormats)) {
                const compat = engineEntries[name];
                const compatible = compat ? compat.compatible : true;
                const reason = compat && !compatible ? compat.reason : '';
                engines.push({
                    name,
                    label: ENGINE_LABELS[name] || name,
                    formats,
                    compatible,
                    reason,
                });
            }

            if (!this.overrideCompat) {
                // Show compatible engines first, then incompatible (disabled)
                engines.sort((a, b) => {
                    if (a.compatible !== b.compatible) return a.compatible ? -1 : 1;
                    return 0;
                });
            }

            return engines;
        },

        get selectedEngineCompatible() {
            if (!this.form.engine_name || !this.form.agent_id) return true;
            const eng = this.availableEngines.find(e => e.name === this.form.engine_name);
            return eng ? eng.compatible : true;
        },

        async launch() {
            this.launching = true;

            // Use search text as model_path if not set by combobox selection
            if (!this.form.model_path) {
                this.form.model_path = document.querySelector('[x-data="modelCombobox()"] input')?.value || '';
            }

            const payload = { ...this.form };
            if (this.overrideCompat) {
                payload.force = true;
            }

            try {
                const resp = await fetch('/api/v1/quicktest/', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload),
                });
                const data = await resp.json();
                if (data.id) {
                    window.location = '/quicktest/' + data.id;
                } else {
                    alert(data.error || 'Failed to launch test');
                    this.launching = false;
                }
            } catch (e) {
                alert('Failed to connect to server: ' + e.message);
                this.launching = false;
            }
        },
    };
}

function modelCombobox() {
    return {
        search: '',
        open: false,
        highlighted: 0,

        get filtered() {
            const q = this.search.toLowerCase();
            let models = this.$data.allModels || [];

            // Filter by engine format compatibility (unless override is on)
            if (!this.$data.overrideCompat) {
                const engine = this.$data.form?.engine_name;
                const engineFmts = this.$data.engineFormats || {};
                const supported = engine && engineFmts[engine];
                if (supported && supported.length) {
                    models = models.filter(m => {
                        if (!m.formats || !m.formats.length) return true;
                        return m.formats.some(f => supported.includes(f));
                    });
                }
            }

            if (!q) return models;
            return models.filter(m =>
                m.model_id.toLowerCase().includes(q)
            );
        },

        selectModel(model) {
            this.search = model.model_id;
            this.open = false;
            // Set the parent form's model_path
            this.$data.form.model_path = model.path;
        },

        selectHighlighted() {
            if (this.filtered.length > 0 && this.highlighted < this.filtered.length) {
                this.selectModel(this.filtered[this.highlighted]);
            } else {
                // Manual entry — use search text as model_path
                this.$data.form.model_path = this.search;
                this.open = false;
            }
        },

        highlightNext() {
            if (this.highlighted < this.filtered.length - 1) {
                this.highlighted++;
            }
        },

        highlightPrev() {
            if (this.highlighted > 0) {
                this.highlighted--;
            }
        },

        formatSize(bytes) {
            if (!bytes) return '';
            const gb = bytes / (1024 * 1024 * 1024);
            return gb >= 1 ? gb.toFixed(1) + ' GB' : (bytes / (1024 * 1024)).toFixed(0) + ' MB';
        },
    };
}
</script>
{% endblock %}
