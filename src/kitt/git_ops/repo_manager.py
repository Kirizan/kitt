"""KARR (Kirby's AI Results Repo) repository management."""

import logging
import subprocess
from pathlib import Path
from typing import Optional

import git
from git import Repo

logger = logging.getLogger(__name__)


class KARRRepoManager:
    """Manage KARR (Kirby's AI Results Repo) repositories."""

    @staticmethod
    def create_results_repo(repo_path: Path, hardware_fingerprint: str) -> Repo:
        """Create a new KARR results repository with proper structure.

        Args:
            repo_path: Path for new repo.
            hardware_fingerprint: Hardware fingerprint for this repo.

        Returns:
            Initialized Git repository.
        """
        repo_path.mkdir(parents=True, exist_ok=True)

        repo = git.Repo.init(repo_path)

        KARRRepoManager._init_git_lfs(repo_path)
        KARRRepoManager._create_gitattributes(repo_path)
        KARRRepoManager._create_gitignore(repo_path)
        KARRRepoManager._create_readme(repo_path, hardware_fingerprint)

        (repo_path / "hardware_fingerprint.txt").write_text(hardware_fingerprint)

        repo.index.add([
            ".gitattributes",
            ".gitignore",
            "README.md",
            "hardware_fingerprint.txt",
        ])
        repo.index.commit("Initial commit: KARR results repository")

        return repo

    @staticmethod
    def _init_git_lfs(repo_path: Path) -> None:
        """Initialize Git LFS in repository."""
        try:
            subprocess.run(
                ["git", "lfs", "install"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.warning(
                "Git LFS initialization failed - LFS may not be installed"
            )

    @staticmethod
    def _create_gitattributes(repo_path: Path) -> None:
        """Create .gitattributes for LFS tracking."""
        content = """# Track large compressed files with Git LFS
*.jsonl.gz filter=lfs diff=lfs merge=lfs -text
*.log.gz filter=lfs diff=lfs merge=lfs -text
*.bin filter=lfs diff=lfs merge=lfs -text

# Don't track small metadata files with LFS
*.json -filter -diff -merge text
*.md -filter -diff -merge text
*.yaml -filter -diff -merge text
"""
        (repo_path / ".gitattributes").write_text(content)

    @staticmethod
    def _create_gitignore(repo_path: Path) -> None:
        """Create .gitignore."""
        content = """# Python
__pycache__/
*.py[cod]
*$py.class
.Python
*.so

# IDE
.vscode/
.idea/
*.swp
*.swo

# Temp files
*.tmp
*.temp
.DS_Store
"""
        (repo_path / ".gitignore").write_text(content)

    @staticmethod
    def _create_readme(repo_path: Path, hardware_fingerprint: str) -> None:
        """Create README for KARR results repo."""
        content = f"""# KARR - Kirby's AI Results Repo

This repository contains LLM inference benchmark results for the following hardware:

**Hardware Fingerprint**: `{hardware_fingerprint}`

## Structure

```
{repo_path.name}/
├── {{model_name}}/
│   └── {{engine_name}}/
│       └── {{timestamp}}/
│           ├── config.json          # Benchmark configuration
│           ├── metrics.json         # Aggregate metrics
│           ├── summary.md           # Human-readable summary
│           ├── hardware.json        # Detailed hardware info
│           ├── outputs/             # Benchmark outputs (compressed, chunked)
│           └── logs/                # Benchmark logs (compressed, chunked)
```

## Generated By

Results are generated by [KITT (Kirby's Inference Testing Tools)](https://github.com/user/kitt).

```bash
kitt results submit
```

## Repository Management

### Shallow Clone

```bash
git clone --depth 1 <repo-url>
```

### Cleanup Old Results

```bash
kitt results cleanup --days 90
```

## Hardware Details

See `hardware_fingerprint.txt` for the full system specification.
"""
        (repo_path / "README.md").write_text(content)

    @staticmethod
    def find_results_repo(fingerprint: str) -> Optional[Path]:
        """Find existing KARR repo for given fingerprint.

        Searches current directory and parent directories.
        """
        current = Path.cwd()
        repo_name = f"karr-{fingerprint}"

        if (current / repo_name).exists():
            return current / repo_name

        for parent in current.parents:
            if (parent / repo_name).exists():
                return parent / repo_name

        return None

    @staticmethod
    def store_results(
        repo_path: Path,
        model_name: str,
        engine_name: str,
        timestamp: str,
        files: dict,
    ) -> None:
        """Store result files in the KARR repo structure.

        Args:
            repo_path: Path to KARR repository.
            model_name: Name of the model tested.
            engine_name: Name of the engine used.
            timestamp: Timestamp string for this run.
            files: Dict of {filename: content} to store.
        """
        result_dir = repo_path / model_name / engine_name / timestamp
        result_dir.mkdir(parents=True, exist_ok=True)

        for filename, content in files.items():
            filepath = result_dir / filename
            filepath.parent.mkdir(parents=True, exist_ok=True)
            if isinstance(content, bytes):
                filepath.write_bytes(content)
            else:
                filepath.write_text(str(content))

        logger.info(f"Results stored in {result_dir}")
